############################################
# Modified from emilis bash prompt script
# from https://github.com/emilis/emilis-config/blob/master/.bash_ps1
#
# Modified for Mac OS X by
# @corndogcomputer
###########################################
# (these are recalculated every time the prompt is shown in function prompt_command):
fill=
gitinfo=

# The current hostname, to be shown
# above every prompt
hostname=`hostname -f`

## COLORS ###
           RED="\[\033[0;31m\]"
     LIGHT_RED="\[\033[1;31m\]"
        YELLOW="\[\033[1;33m\]"
        ORANGE="\[\033[0;33m\]"
          BLUE="\[\033[0;34m\]"
    LIGHT_BLUE="\[\033[1;34m\]"
         GREEN="\[\033[0;32m\]"
   LIGHT_GREEN="\[\033[1;32m\]"
          CYAN="\[\033[0;36m\]"
    LIGHT_CYAN="\[\033[1;36m\]"
        PURPLE="\[\033[0;35m\]"
    LIGHT_PURPLE="\[\033[1;35m\]"
        WHITE="\[\033[1;37m\]"
    LIGHT_GRAY="\[\033[0;37m\]"
         BLACK="\[\033[0;30m\]"
          GRAY="\[\033[1;30m\]"
    BOLD_BLACK="\[\033[00m\]\[\033[1;29m\]"
      NO_COLOR="\[\e[0m\]"


# Reset color for command output
# (this one is invoked every time before a command is executed):
trap 'echo -ne "\033[00m"' DEBUG


# This will parse `git status` output
# to show the current working branch,
# and any incoming / outgoing changes.
function parse_git_branch {
    branch=
    remote=
    state=
    statuscolor=
    bracket=
    
    git rev-parse --git-dir &> /dev/null
    git_status="$(git status 2> /dev/null)"
    branch_pattern="^# On branch ([^${IFS}]*)"
    detached_branch_pattern="# Not currently on any branch"
    remote_pattern="# Your branch is (.*) of"
    diverge_pattern="# Your branch and (.*) have diverged"

    if [[ ${git_status}} =~ "Changed but not updated" ]]; then
        statuscolor=${RED}
        state="⚡"
    fi

    # add an else if or two here if you want to get more specific
    if [[ ${git_status} =~ ${remote_pattern} ]]; then
        if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
            statuscolor=${YELLOW}
            remote="↑"
        else
            statuscolor=${YELLOW}
            remote="↓"
        fi
    fi

    if [[ ${git_status} =~ ${diverge_pattern} ]]; then
        statuscolor=${YELLOW}
        remote="${YELLOW}↕"
    fi

    if [[ ${git_status} =~ ${branch_pattern} ]]; then
        branch=${BASH_REMATCH[1]}
    elif [[ ${git_status} =~ ${detached_branch_pattern} ]]; then
        statuscolor=${YELLOW}
        branch="NO BRANCH"
    fi

    if [[ ${#state} -gt "0" || ${#remote} -gt "0" ]]; then
        s=" "
    fi

    gitinfo="${branch}${s}${remote}${state}"
}


# Retrieves git repository information
# and calculates the size of the dashed
# line above the prompt.
function prompt_command {
     parse_git_branch

    if [ ! -z "$gitinfo" ]
    then
        branch="($branch"
        bracket=")"
    fi
     
  	# create a dashed line as wide as the screen,
    # minus the time string (8 chars), the hostname,
    # a few spaces and separators (5 chars):
  	let fillsize=${COLUMNS}-13-${#hostname}
  	fill=""

  	while [ "$fillsize" -gt "0" ]
  	do
  		  fill="-${fill}" # fill with dashes to work on
  		  let fillsize=${fillsize}-1
  	done
}

# Finally, prepare the prompt:
export PROMPT_COMMAND=prompt_command
export PS1=${LIGHT_GRAY}'$fill '${GREEN}'$hostname'${LIGHT_GRAY}' -- \t\n'"${LIGHT_PURPLE}\u${LIGHT_GRAY}${NO_COLOR}${LIGHT_BLUE}:\w${NO_COLOR}"' ${branch}${s}'"${statuscolor}"'${remote}${state}'"${NO_COLOR}"'${bracket}'"${NO_COLOR}\$ ${BOLD_BLACK}"
